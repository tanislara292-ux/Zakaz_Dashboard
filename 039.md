Задача для кодера: вернуть поддержку QTickets GET /orders с корректными фильтрами
Источник спецификации: /workspaces/Zakaz_Dashboard/qtickesapi.md (обязательно пролистать разделы “Список заказов” и “Массив where”).

1. Общая цель
Вернуть клиенту возможность получать заказы через GET /orders в формате, поддерживаемом QTickets.
Фильтрацию и сортировку реализовать так, как описано в qtickesapi.md: where (параметр JSON), orderBy и пагинация через query.
Перестать отправлять POST-тело на /orders – QTickets его не принимает (503).
2. Правки кода
2.1. dashboard-mvp/integrations/qtickets_api/client.py
Метод fetch_orders_get должен:

Формировать where как список словарей:
filters = [
    {"column": "payed", "value": 1},
    {"column": "payed_at", "operator": ">=", "value": "<iso from>"},
    {"column": "payed_at", "operator": "<", "value": "<iso to>"}
]
Значения дат формируем через уже готовые функции (to_msk + .isoformat()).
Собирать словарь параметров:
params = {
    "organization": self.org_name,
    "where": json.dumps(filters, ensure_ascii=False),
    "orderBy": json.dumps({"payed_at": "desc"}),
    "page": 1,
    "per_page": 200
}
Передавать параметры в _collect_paginated("orders", params=params) — это должна быть GET-версия (без body).
_collect_paginated уже умеет добавлять page, просто убедись, что JSON-строки не перезаписываются (если нужно, добавь if "page" not in params).
После получения данных — фильтровать по payed_at локально (как было), чтобы убрать лишнее по дате, на случай если QTickets всё ещё отдаёт старые записи.
Добавить логирование: какие фильтры используем, какие даты.
Метод _format_datetime_for_api больше не нужен (если добавлялся) — можешь удалить или использовать только для генерации isoformat.

2.2. Обновление тестов dashboard-mvp/integrations/qtickets_api/tests/test_client.py
Тест test_fetch_orders_get_includes_payed_filter переписать под GET:
Проверить, что method == "GET".
Убедиться, что params["where"] внутри содержит JSON-строку, которую при json.loads можно разобрать в список с нужными фильтрами (payed, payed_at >=, payed_at <).
Проверить, что orderBy также JSON-строка { "payed_at": "desc" }.
per_page и page — присутствуют.
Если есть другие тесты, которые ожидают POST, обнови или удали.
3. Рефакторинг (если потребуется)
В client.py мог появиться вспомогательный метод _format_datetime_for_api — оставь только если действительно используется.
Убедись, что list_orders_since и fetch_orders_since теперь работают штатно (они вызывают fetch_orders_get).
Если где-то остались зависания на POST – убери.
4. Проверка вручную (dev-сервер)
Подтянуть последние изменения (git pull origin main).

Удалить тестовые директории из рабочей копии (если мешают) — но не забыть, что они уже есть в коммите 036/037/038.

Прогнать локальную проверку:

python - <<'PY'
from datetime import timedelta
from integrations.qtickets_api.client import QticketsApiClient
from integrations.common.time import now_msk
import os, json

client = QticketsApiClient(
    base_url=os.environ["QTICKETS_BASE_URL"],
    token=os.environ["QTICKETS_TOKEN"],
    org_name=os.environ.get("ORG_NAME"),
)

end = now_msk()
start = end - timedelta(days=30)
orders = client.fetch_orders_get(start, end)
print("orders:", len(orders), "first:", orders[0]["payed_at"] if orders else "N/A")
Важно: переменные окружения подгрузить из /opt/zakaz_dashboard/secrets/.env.qtickets_api.
curl для контроля:

SINCE=$(TZ='Europe/Moscow' date -d '30 days ago' +"%Y-%m-%dT%H:%M:%S%z")
UNTIL=$(TZ='Europe/Moscow' date +"%Y-%m-%dT%H:%M:%S%z")
curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&where=%5B%7B%22column%22%3A%22payed%22%2C%22value%22%3A1%7D%2C%7B%22column%22%3A%22payed_at%22%2C%22operator%22%3A%22%3E%3D%22%2C%22value%22%3A%22$SINCE%22%7D%2C%7B%22column%22%3A%22payed_at%22%2C%22operator%22%3A%22%3C%22%2C%22value%22%3A%22$UNTIL%22%7D%5D&orderBy=%7B%22payed_at%22%3A%22desc%22%7D&per_page=200&page=1"
Это where и orderBy, закодированные в query. Раскодировать можно в python через urllib.parse.unquote — проверим, что структура соответствует doc'у.

Если наконец появляются записи с 2025 (посмотреть payed_at), тест прошёл.

5. Прогон loader
В .env для проверки можно QTICKETS_SINCE_HOURS=720.
Очистить ClickHouse (если он сейчас пустой после тестов 036/038, очистка не обязательна, но зафиксируй состояние).
Запустить контейнер интеграции (см. инструкцию предыдущих задач).
Убедиться, что в stg_qtickets_api_orders_raw и fact_qtickets_sales_daily появились строки с датами 2025 (посмотреть min(order_ts), max(order_ts)).
meta_job_runs должен показать orders > 0.
6. Отчёт
Подготовить краткий отчёт:
Какие изменения внесены.
Вывод curl (например, первые 2 записи).
Снимок ClickHouse.
Если свежих продаж всё равно нет (менее вероятно) — зафиксировать actual answer (может быть справедливо, если у клиента действительно пока нет; но тогда это должны быть 0 на GET, а не 503).
7. Привязка к qtickesapi.md
В коде оставить комментарий, что where/orderBy формируются согласно документу qtickesapi.md.
В задаче для репозиторного change-log указать эту ссылку как источник.
8. После проверки
Вернуть QTICKETS_SINCE_HOURS к рабочему значению (например, 4).
Убедиться, что ClickHouse содержит данные (если перед запуском чистили — возможно, стоит восстановить или запросить повторную выгрузку).
Сделать git status, pytest tests/test_client.py (и другие тесты при необходимости).