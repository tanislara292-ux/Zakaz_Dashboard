Задача: прогнать боевой тест QTickets‑интеграции на dev-среде и зафиксировать полный трейс

Цель
Подтвердить, что API QTickets отдаёт заказы, и что загрузчик корректно пишет их в ClickHouse (staging + факт). Нужны детальные логи HTTP-запросов и итоговые значения в таблицах.

1. Подготовка
Убедись, что активен dev-сервер (тот, где мы сейчас работаем: /opt/zakaz_dashboard/dashboard-mvp).
Используй боевой токен и ORG_NAME, которые заказчик предоставил.
В /opt/zakaz_dashboard/secrets/.env.qtickets_api установи:
DRY_RUN=false
QTICKETS_SINCE_HOURS=720 (месяц) – если уже стояло больше, оставь; задача — покрыть период, в котором наверняка были продажи.
Проверь QTICKETS_BASE_URL, ORG_NAME, QTICKETS_TOKEN — никаких заглушек/REPLACE_* быть не должно.
2. Логирование вызовов API
Перед запуском сделай прямой HTTP-запрос к endpoint’у orders, записав ответ в файл:

curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&since=<ISO8601 from 30 days ago>" \
  | jq '.' > /opt/zakaz_dashboard/logs/qtickets_orders_raw.json
(подставь дату, например 2025-10-04T00:00:00Z).

То же для events (чтобы понимать список актуальных событий):

curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/events?organization=$ORG_NAME&page=1" \
  | jq '.' > /opt/zakaz_dashboard/logs/qtickets_events_raw.json
Если API возвращает пагинацию/несколько страниц, прогонить нужное число страниц и логировать каждую в отдельный файл, чтобы была полная картина.

3. Запуск загрузчика с расширенными логами
В /opt/zakaz_dashboard/secrets/.env.qtickets_api добавь (если нет):
LOG_LEVEL=DEBUG
Создай/очисти директорию под логи:
mkdir -p /opt/zakaz_dashboard/logs
rm -f /opt/zakaz_dashboard/logs/qtickets_loader.log
Запусти загрузчик:
docker run --rm \
  --network clickhouse_default \
  --env-file /opt/zakaz_dashboard/secrets/.env.qtickets_api \
  qtickets_api:latest \
  --verbose 2>&1 | tee /opt/zakaz_dashboard/logs/qtickets_loader.log
(Если в коде нет ключа --verbose, просто направь stdout/stderr в лог.)
4. Проверка ClickHouse
stg_qtickets_api_orders_raw:

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "SELECT count(), min(order_ts), max(order_ts) FROM zakaz.stg_qtickets_api_orders_raw;"
fact_qtickets_sales_daily:

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT
      min(sales_date),
      max(sales_date),
      sum(tickets_sold),
      sum(revenue)
    FROM zakaz.fact_qtickets_sales_daily;
  "
Если counts > 0, выгрузи примеры:

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT sales_date, event_id, event_name, tickets_sold, revenue
    FROM zakaz.fact_qtickets_sales_daily
    ORDER BY sales_date DESC, revenue DESC
    LIMIT 50;
  " > /opt/zakaz_dashboard/logs/fact_sales_sample.tsv
Зафиксируй meta_job_runs (последние записи с распарсенным JSON message):

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT job, status, started_at, finished_at, message
    FROM zakaz.meta_job_runs
    WHERE job = 'qtickets_api'
    ORDER BY finished_at DESC
    LIMIT 5
    FORMAT PrettyCompact;
  " > /opt/zakaz_dashboard/logs/meta_job_runs_latest.txt
5. Что предоставить по итогам
qtickets_orders_raw.json / qtickets_events_raw.json (сырые ответы API).
qtickets_loader.log (stdout/stderr контейнера).
Скрины/вывод запросов по ClickHouse (counts, date ranges, sample rows). Можно приложить файлы из каталога /opt/zakaz_dashboard/logs.
Краткое описание результата:
Сколько заказов вернул API (по логам).
Сколько строк попало в stg_qtickets_api_orders_raw.
Заполнился ли fact_qtickets_sales_daily.
Есть ли расхождения/ошибки (например, API всё равно отдаёт 0 заказов).
Если заказов нет — указать, что за период проверялось, и привести фрагмент ответа API (чтобы заказчик видел, что проблема на их стороне).
6. Дополнительно (если обнаружены проблемы)
Если API возвращает ошибки/пустой массив — зафиксируй точный текст ответа.
Если loader падает — приложи стек-трейс.
Если данные приходят, но не пишутся в факт — распиши, на какой стадии они «теряются» (по логам и содержимому staging).