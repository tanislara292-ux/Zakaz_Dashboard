Задача: “QTickets /orders — подтверждаем наличие свежих продаж (2025)”
Источник правды: Исследование.docx / Исследование.md + архив logs/qtickets_orders_debug.tar.gz (но помним: там только результаты за 2021; нашей целью остаётся 2025).

Общие требования
Работаем на dev-сервере: /opt/zakaz_dashboard/dashboard-mvp.
Используем боевой .env: /opt/zakaz_dashboard/secrets/.env.qtickets_api. Никаких замен токена не делаем, но значения выводим в лог (маскируя токен).
Все шаги фиксируются. Любая команда → отдельный файл в каталоге logs/qtickets_orders_2025/. Перед началом:
mkdir -p /opt/zakaz_dashboard/logs/qtickets_orders_2025
rm -f /opt/zakaz_dashboard/logs/qtickets_orders_2025/*
Формат именования: step##_description.txt/json.
Параметры времени. Работаем в MSK (Europe/Moscow). Для ISO-строк:
TZ='Europe/Moscow' date -d '2025-10-01 00:00:00' +"%Y-%m-%dT%H:%M:%S%z"
Убедиться в реальных продажах. Возьми ID заказа из недавнего письма (или снабдись через заказчика). Это важно для шага D.
Шаг 0. Базовая настройка
Загрузить env и зафиксировать в step00_env.txt:
source /opt/zakaz_dashboard/secrets/.env.qtickets_api
{
  echo "QTICKETS_BASE_URL=$QTICKETS_BASE_URL"
  echo "ORG_NAME=$ORG_NAME"
  echo "REPORT_TZ=$REPORT_TZ"
  echo "QTICKETS_SINCE_HOURS=$QTICKETS_SINCE_HOURS"
  echo "TOKEN_FP=$(echo "$QTICKETS_TOKEN" | sed 's/\(.\{4\}\).*/\1*** (masked)/')"
} > /opt/zakaz_dashboard/logs/qtickets_orders_2025/step00_env.txt
Шаг A. Прямые curl на текущие периоды
Все ответы (body + headers) сохраняй. В outcome-файле укажи URL с подставленными параметрами и количество элементов.

A1. Последние 30 дней
SINCE30=$(TZ='Europe/Moscow' date -d '30 days ago' +"%Y-%m-%dT%H:%M:%S%z")
curl -s -D /opt/zakaz_dashboard/logs/qtickets_orders_2025/stepA1_headers.txt \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=$SINCE30&page=1&per_page=200" \
  > /opt/zakaz_dashboard/logs/qtickets_orders_2025/stepA1_body.json
Сделай outcome-файл:

HTTP Status: ...
Orders Count: (если массив – длина через jq '.data|length' или '.|length')
Request URL: (подставить фактический URL с параметрами)
A2. Последние 7 дней
Аналогично, SINCE7. Сохраняем stepA2_*.

A3. Последние 24 часа
SINCE24. Сохраняем stepA3_*.

Шаг B. Проверяем конкретный Order ID
Возьми ID из свежего письма (если несколько, можешь проверить 2-3).
Запрос:
ORDER_ID=...
curl -s -D /opt/zakaz_dashboard/logs/qtickets_orders_2025/stepB_${ORDER_ID}_headers.txt \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders/$ORDER_ID?organization=$ORG_NAME" \
  > /opt/zakaz_dashboard/logs/qtickets_orders_2025/stepB_${ORDER_ID}_body.json
В outcome: HTTP-код, есть ли JSON с данными (если пусто – прямо пишем {} / null), timestamp.
Шаг C. Эксперименты со статусами
Только если шаг A дал пустые ответы (иначе А → сразу шаг D).

C1. payed=1 + status=paid (30 дней)
Сохраняем stepC1_*.

C2. status=paid без payed
stepC2_*.

C3. status=completed
stepC3_*.

Шаг D. POST (если GET даёт пусто)
POST /orders/filter

Создай файл post_filter_body.json с фильтром payed и payed_at (2025-10-01 → сегодняшний день).
curl -s -D stepD1_headers.txt -H "Content-Type: application/json" -X POST ... --data @post_filter_body.json > stepD1_body.json
POST /orders (если API требует именно этот endpoint).

Аналогично stepD2_*.
Если любой POST/GET выдаёт 503 — зафиксируй body (должен быть {"error":"Unknown error","status":503,...}), время, полный URL — всё идёт в итоговый отчёт.

Шаг E. Loader (только если хотя бы один запрос вернул данные по 2025)
В .env временно ставим широкое окно, чтобы захватить период, где нашлось >0 (например, QTICKETS_SINCE_HOURS=240).

Запускаем:

docker run --rm \
  --network clickhouse_default \
  --env-file /opt/zakaz_dashboard/secrets/.env.qtickets_api \
  qtickets_api:latest \
  --verbose 2>&1 | tee /opt/zakaz_dashboard/logs/qtickets_orders_2025/stepE_loader.log
Проверяем ClickHouse:

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "SELECT count(), min(order_ts), max(order_ts) FROM zakaz.stg_qtickets_api_orders_raw;"
→ запиши вывод в stepE_loader_stg.txt.

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT
      min(sales_date),
      max(sales_date),
      sum(tickets_sold),
      sum(revenue)
    FROM zakaz.fact_qtickets_sales_daily;
  "
→ stepE_loader_fact.txt.

Шаг F. Итоговый отчёт
Создаём final_report.md (в qtickets_orders_2025/):

Таблица: шаг → URL → HTTP-код → длина → вывод.
Приложи выдержки (jq '.data[:3]' и др.)
Если ни один запрос на свежие даты не дал данных → зафиксировать “0” с точным временем, URL и заголовками (Чтобы в поддержку QTickets было что отправить).
Приложить краткий вывод: “Свежий заказ ID ХХХ — API вернул/не вернул”.
Закрыть отчёт рекомендацией: либо “API отдаёт новые продажи, можно ставить cron”, либо “API не отдаёт свежие продажи, нужна эскалация (приложены логи)”.
Создать архив:

cd /opt/zakaz_dashboard/logs
tar -czf qtickets_orders_2025.tar.gz qtickets_orders_2025
Условия завершения
Каждый шаг имеет файлы (body, headers, outcome).
Итоговый final_report.md содержит таблицу + комментарии.
Если обнаружены свежие продажи → в отчёте есть COUNT, даты, revenue; в ClickHouse соответствующие таблицы содержат >0 записей с 2025 годом.
Если всё равно пусто → отчёт содержит доказательства (часть писем + API-ответы) и рекомендацию обратиться в QTickets.
Никаких пропусков шагов. Если какой-то шаг не применим (например, GET уже вернул данные — можно не делать POST, но обязательно написать в final_report.md, что причину пропуска “GET работает, POST не требуется”.
После выполнения верни .env к прежнему QTICKETS_SINCE_HOURS (например, 4), если ты его менял.