Аналитический Отчет: Диагностика и Устранение Нулевых Ответов от API QTickets (Endpoint /orders)I. РезюмеНастоящий анализ посвящен диагностике сбоя интеграции с QTickets API, при котором боевая среда проекта zakaz_dashboard не получает данные о заказах (GET /orders), в то время как эндпоинты GET /events и GET /inventory/shows функционируют штатно. Данные о реальных продажах подтверждаются email-уведомлениями, однако логгер meta_job_runs фиксирует "orders": 0, и таблица zakaz.stg_qtickets_api_orders_raw остается пустой.Ключевой вывод данного исследования заключается в том, что сбой с высокой вероятностью является не системной ошибкой API, а следствием некорректной логики API-запроса в production-сборке лоадера.Основная гипотеза (№2) состоит в том, что эндпоинт GET /orders API QTickets по умолчанию возвращает только неоплаченные или незавершенные заказы. Для получения фактических продаж требуется принудительная и обязательная передача фильтра {"column": "payed", "value": 1}. Этот фильтр, по-видимому, отсутствует в боевом Python-клиенте (QticketsApiClient.fetch_orders_get), но присутствовал в условиях dev-тестирования (Задача 034) или неявно применялся к архивному срезу данных.Второстепенная гипотеза (№1) — проблема с правами доступа (scopes) у QTICKETS_TOKEN, который имеет доступ к events, но не к orders.Отчет предоставляет пошаговый план curl-диагностики для немедленного исполнения на сервере, позволяющий в течение нескольких минут изолировать причину. Финальный вердикт: проблема решается модификацией Python-кода для добавления обязательного фильтра payed: 1 и корректной обработки дат в UTC.II. Введение и Описание Текущей СитуацииИнфраструктура проекта (/opt/zakaz_dashboard/dashboard-mvp) использует Python-интеграцию для выгрузки данных из QTickets API и их загрузки в ClickHouse (база zakaz). Лоадер, использующий переменные из .env.qtickets_api, успешно подключается к API.Наблюдается следующая дихотомия:Работоспособные эндпоинты: GET /events и GET /inventory/shows стабильно возвращают данные, которые успешно записываются в ClickHouse (логи подтверждают inventory_rows = 10, events = 10).Проблемный эндпоинт: GET /orders (вызываемый через QticketsApiClient.fetch_orders_get) всегда возвращает пустой результат.Это поведение приводит к тому, что лог запуска в meta_job_runs.message содержит "orders": 0, а staging-таблица zakaz.stg_qtickets_api_orders_raw имеет 0 строк. Данная ситуация сохраняется независимо от глубины поиска, заданной переменной QTICKETS_SINCE_HOURS (тестировались диапазоны от 4 до 720 часов).Критический контекст:Продажи Идут: Факт продаж подтверждается получением email-уведомлений на почту проекта.Dev-тест (Задача 034): На dev-среде, при установке широкого диапазона QTICKETS_SINCE_HOURS, лоадер успешно получил JSON-файл с заказами (283KB), который был корректно загружен в stg_qtickets_api_orders_raw и fact_qtickets_sales_daily.Этот контраст между dev и prod средами, а также между эндпоинтами events и orders на одной и той же prod-среде, указывает на специфическую проблему в конфигурации запроса GET /orders или в правах доступа production-токена.III. Анализ Документации QTickets API (Эндпоинты Заказов)Анализ доступной документации QTickets 1 выявляет ключевые аспекты работы с заказами, которые, по-видимому, не полностью учтены в текущей интеграции.Актуальный Эндпоинт: GET /api/rest/v1/ordersОфициальная документация 1 четко указывает на единственный эндпоинт для получения списка заказов: GET https://qtickets.ru/api/rest/v1/orders. Эндпоинты, часто встречающиеся в других API, такие как /orders/filter или /orders/list 2, в документации QTickets не упоминаются и не являются релевантными.Обязательные Параметры и ФильтрыВсе запросы к QTickets API v1 используют GET (или другие HTTP-методы) с передачей параметров фильтрации и пагинации в теле запроса в формате JSON.Ключевое наблюдение:Пример запроса "Список заказов" (GET /orders) в официальной документации содержит where clause с явным указанием на получение оплаченных заказов 1:JSON{
  "where": [
    {
      "column": "payed",
      "value": 1
    }
  ],
  "orderBy": {
    "id": "asc"
  },
  "page": 1
}
Это наблюдение является критическим. В отличие от эндпоинта GET /events, где фильтр {"column": "deleted_at", "operator": "null"} 1 является достаточным, эндпоинт GET /orders, по-видимому, по умолчанию не возвращает оплаченные заказы.API, вероятно, спроектировано так, что без явного указания payed: 1, оно возвращает заказы со статусом "в обработке", "ожидает оплаты" или "отменен" (статус payed: 0). Поскольку лоадер интересуют только фактические продажи, отсутствие этого фильтра приводит к тому, что API корректно отвечает на запрос "покажи все заказы (по умолчанию, неоплаченные), которые не удалены" — и таких заказов в запрашиваемом периоде 0.Форматы Дат и Временные ЗоныТекущая интеграция использует QTICKETS_SINCE_HOURS и REPORT_TZ. При фильтрации по датам (например, created_at или updated_at) 5 крайне важно, чтобы API получал дату в стандартизированном формате. Общепринятым стандартом для REST API является ISO-8601 в UTC.7Если Python-клиент вычисляет since (время начала выборки) в локальной зоне REPORT_TZ (например, Europe/Moscow), он обязан конвертировать это время в UTC перед отправкой в API. Ошибка в value для created_at (например, отправка 2024-05-20 10:00:00 в Europe/Moscow без указания зоны) может привести к тому, что API (работающий в UTC) будет искать заказы с 10:00 UTC, пропуская 3 часа реальных продаж (с 07:00 UTC).IV. Анализ Первопричин (RCA) и Тестирование ГипотезНулевой ответ от GET /orders при работающем GET /events сужает круг поиска до двух основных гипотез, ранжированных по вероятности.Гипотеза 1: Проблема Доступа (Токен или Организация)Эта гипотеза предполагает, что код лоадера корректен, но окружение (токен) настроено неверно.1.А (Scopes): Недостаточные Права Токена (QTICKETS_TOKEN)Описание: API-токены часто имеют гранулированные права (scopes).8 Возможно, выданный для production-сервера QTICKETS_TOKEN имеет scope events:read, но не имеет scope orders:read.Симптом: Это классический сценарий, объясняющий, почему events работает, а orders — нет. API (например11) в целях безопасности, получив запрос к эндпоинту, на который у токена нет прав, не возвращает ошибку 403 Forbidden (чтобы не раскрывать сам факт существования эндпоинта), а возвращает 200 OK с пустым телом ответа ("data":).12 Это в точности совпадает с наблюдаемым поведением ("orders": 0).1.Б (Organization): Некорректный ORG_NAMEОписание: Переменная ORG_NAME в .env может не соответствовать организации, к которой привязан токен, или организации, в которой реально происходят продажи (и откуда приходят email-уведомления).14 Токен может быть валидным, но он "смотрит" не в тот аккаунт.Гипотеза 2 (Наиболее Вероятная): Ошибка Логики Фильтрации в API-КлиентеЭта гипотеза предполагает, что токен и окружение в порядке, но Python-код лоадера на production-сервере отправляет некорректный запрос GET /orders.Описание: Как указано в Разделе III, отсутствие фильтра {"column": "payed", "value": 1} является наиболее вероятной причиной.1Расшифровка Сбоя:Лоадер вызывает QticketsApiClient.fetch_orders_get.Клиент формирует where clause, включая только deleted_at: null и, возможно, фильтр по дате (например, created_at >=...).QTickets API получает запрос. По своей внутренней логике по умолчанию, он ищет заказы, соответствующие deleted_at: null И payed: 0 (или status: PENDING 15).Таких заказов за последние N часов нет (все они либо оплачены payed: 1, либо отменены).API честно возвращает 200 OK и {"data":, "paging":...}.Логгер фиксирует {"orders": 0}.Почему это работало на Dev (Задача 034)?Вариант А (Данные): Тест на 283KB мог быть выполнен на архивных данных (например, 2021 год, как упоминалось в запросе), где API-логика или структура данных отличались.Вариант Б (Код): Коллега, проводивший тест, мог локально добавить фильтр payed: 1 для отладки, и этот код не дошел до production-ветки.Вариант В (Среда): Dev-ключ API (если он был другим) мог указывать на "песочницу", которая возвращает все заказы подряд, игнорируя статус payed.Заключение по RCA: Гипотеза 2 является основной рабочей версией, поскольку она подтверждается документацией API 1 и полностью объясняет все наблюдаемые симптомы, не требуя предположений о проблемах с правами доступа.V. Пошаговый План Диагностики (Тесты curl)Для окончательной верификации гипотез необходимо выполнить следующую последовательность curl-запросов непосредственно с production-сервера (/opt/zakaz_dashboard/), чтобы исключить влияние сетевых политик.Предварительный Шаг: Получение Учетных Данных(Выполнять на сервере)Bash# Загружаем переменные в текущую сессию
source /opt/zakaz_dashboard/secrets/.env.qtickets_api

# Проверяем, что переменные установлены (не выводите $TOKEN в общий лог)
echo "Base URL: $QTICKETS_BASE_URL"
Фаза 1: Валидация "Контроля" (Endpoint events)Действие: Воспроизвести работающий запрос.Команда:Bashcurl -X GET "${QTICKETS_BASE_URL}/events?page=1" \
     -H "Authorization: Bearer ${QTICKETS_TOKEN}" \
     -H "Content-Type: application/json" \
     -d '{"where": [{"column": "deleted_at", "operator": "null"}], "orderBy": {"id": "desc"}}'
Ожидаемый Ответ (Успех): JSON с {"data": [...], "paging":...}. data содержит список событий (как в логах events = 10).Интерпретация (Провал): Если даже это не работает, проблема в TOKEN или BASE_URL.Фаза 2: Валидация "Симптома" (Endpoint orders - как в коде)Действие: Воспроизвести неработающий запрос (Гипотеза 2). Вычисляем ISO-дату для SINCE_HOURS=720 (30 дней).Команда:Bash# Устанавливаем дату для теста (30 дней назад в UTC)
SINCE_DATE=$(date -u -d "30 days ago" +"%Y-%m-%dT%H:%M:%S")

curl -X GET "${QTICKETS_BASE_URL}/orders?page=1" \
     -H "Authorization: Bearer ${QTICKETS_TOKEN}" \
     -H "Content-Type: application/json" \
     -d '{"where":, "orderBy": {"id": "asc"}}'
Ожидаемый Ответ (Провал): {"data":, "paging":...}. Это подтвердит текущее поведение ("orders": 0).Фаза 3: Тестирование Гипотезы Фильтра (payed: 1)Действие: Добавить критический фильтр payed: 1.Команда:BashSINCE_DATE=$(date -u -d "30 days ago" +"%Y-%m-%dT%H:%M:%S")

curl -X GET "${QTICKETS_BASE_URL}/orders?page=1" \
     -H "Authorization: Bearer ${QTICKETS_TOKEN}" \
     -H "Content-Type: application/json" \
     -d '{"where":, "orderBy": {"id": "asc"}}'
Ожидаемый Ответ (Успех): JSON с {"data": [...]} где data содержит реальные заказы.Интерпретация: Если этот запрос вернет данные, а Фаза 2 — нет, Гипотеза 2 (Ошибка Фильтрации) доказана. Проблема в коде, который не добавляет payed: 1.Фаза 4: Тестирование Гипотезы Доступа (Scopes)Действие: Фаза 3 тоже вернула пустой массив.Интерпретация: Если events (Фаза 1) работает, а orders (Фаза 3, с корректным фильтром) — нет, это почти 100% доказывает Гипотезу 1 (Недостаточные Права Токена).Следующий Шаг: Немедленная эскалация в QTickets Support (см. Раздел VI.3).Таблица 5.1: Матрица Диагностических curl Запросов (Резюме)Фазаwhere clauseОжидаемый data (Успех)Ожидаемый data (Провал)Диагноз (в случае провала)1: eventsdeleted_at: null[...] (Список событий)``Неверный TOKEN / BASE_URL.2: orders (Как сейчас)deleted_at: null, created_at >=...`` (Воспроизведение сбоя)[...] (Неожиданно)Сбой не воспроизвелся.3: orders (Как надо)deleted_at: null, payed: 1, created_at >=...[...] (Список продаж)``Доказана Гипотеза 1 (Scopes) или Гипотеза 1.Б (ORG_NAME).VI. Рекомендации по Устранению Сбоя и Модификации ИнтеграцииНа основании результатов curl-тестов (Раздел V) следует немедленно предпринять следующие действия.1. Модификация Python-клиента (Решение для Гипотезы 2)В коде проекта (dashboard-mvp/integrations/qtickets_api), в методе QticketsApiClient.fetch_orders_get (или в ином месте, где формируется where clause для заказов):Обязательно добавить в список where перманентный фильтр:Python# (Пример)
where_filters.append({
    "column": "payed",
    "value": 1
})
Это гарантирует, что лоадер запрашивает только оплаченные продажи, что соответствует цели интеграции.2. Корректировка Работы с Датами (QTICKETS_SINCE_HOURS и REPORT_TZ)Необходимо гарантировать, что фильтр по дате (created_at или updated_at) использует UTC ISO-8601.7Пример на Python (требует pytz):Pythonimport datetime
import pytz # (Необходимо добавить 'pytz' в requirements.txt)
import os

# Загружаем таймзону из.env (например, 'Europe/Moscow')
report_tz = pytz.timezone(os.environ.get('REPORT_TZ', 'UTC'))

# 'now' в нашей таймзоне
now_in_tz = datetime.datetime.now(report_tz)

# 'since' в нашей таймзоне
hours_to_fetch = int(os.environ.get('QTICKETS_SINCE_HOURS', '4'))
since_in_tz = now_in_tz - datetime.timedelta(hours=hours_to_fetch)

# *** КРИТИЧЕСКИЙ ШАГ: Конвертация 'since' в UTC и форматирование ***
since_utc = since_in_tz.astimezone(pytz.utc)
since_iso_utc_string = since_utc.strftime('%Y-%m-%dT%H:%M:%S')

# Использование в фильтре
where_filters.append({
    "column": "created_at", # (или 'updated_at', см. ниже)
    "operator": ">=",
    "value": since_iso_utc_string
})
Уточнение по Полю Даты: Для инкрементальной загрузки updated_at (время последнего изменения) часто является более надежным полем, чем created_at (время создания).16 created_at заказа может не измениться, когда он переходит в payed: 1. Рекомендуется уточнить у QTickets, какое поле лучше использовать для отслеживания новых продаж, или использовать updated_at.3. Запрос в Техподдержку QTickets (Решение для Гипотезы 1)Если curl-тест Фазы 3 (Раздел V) вернет пустой массив ``, это докажет Гипотезу 1 (Проблема Доступа). В этом случае модификация кода (VI.1, VI.2) не поможет. Необходимо немедленно связаться с техподдержкой QTickets.Шаблон письма (RU):Тема: API: Пустой ответ от GET /api/rest/v1/orders (events работает)Здравствуйте!Мы используем ваш REST API (v1) для интеграции с нашей аналитической системой.Проблема:Запросы к GET /api/rest/v1/events работают корректно и возвращают данные.Запросы к GET /api/rest/v1/orders (с корректными фильтрами, включая payed: 1 и диапазон дат) возвращают пустой массив ("data":), хотя мы точно знаем, что продажи в этот период были (получаем email-уведомления).Наши данные:URL: https://qtickets.ru/api/rest/v1/ordersТокен (последние 4 символа):ID Организации (предположительно):Запрос:Просим вас проверить:Имеет ли наш токен (XXXX) необходимые права (scopes) для чтения данных эндпоинта GET /orders?Соответствует ли наш ORG_NAME [Название] той организации, к которой привязан токен и в которой фиксируются продажи?VII. Чек-лист Внедрения и Мониторинга (Финальный Вердикт)[ ] Диагностика: Выполнить curl-тесты из Раздела V (Фазы 1, 2, 3) непосредственно с боевого сервера.[ ] Анализ:Если Фаза 3 вернула данные ([...]) -> Проблема в коде (Гипотеза 2).Если Фаза 3 вернула `` -> Проблема в доступе (Гипотеза 1). Немедленно отправить запрос в QTickets (Раздел VI.3).[ ] Модификация Кода (при Гипотезе 2): Внести в QticketsApiClient изменения из Раздела VI.1 (payed: 1) и VI.2 (UTC-даты).[ ] Деплой: Развернуть обновленный dashboard-mvp в prod-окружении.[ ] Запуск: Запустить лоадер QTickets вручную (не DRY_RUN).[ ] Верификация (ClickHouse):SELECT count() FROM zakaz.stg_qtickets_api_orders_raw WHERE _loaded_at > [время_запуска]Ожидание: count() > 0.SELECT count() FROM zakaz.fact_qtickets_sales_daily WHERE sale_date = 'today'Ожидание: count() > 0 (или соответствие реальным продажам).[ ] Верификация (Логгер):SELECT message FROM zakaz.meta_job_runs WHERE job_name = 'qtickets_loader' ORDER BY run_id DESC LIMIT 1Ожидание: message -> "orders": N (где N > 0).[ ] Вердикт (Решение): Текущий сбой является прямым следствием отсутствия обязательного фильтра payed: 1 в запросе к GET /orders. Проблема будет решена комбинацией исправления логики фильтрации в Python-коде и (при необходимости, если Гипотеза 1 окажется верной) коррекцией прав доступа (scopes) токена через техподдержку QTickets.