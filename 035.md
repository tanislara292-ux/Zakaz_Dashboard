Задача: Починить выгрузку заказов QTickets (параметр payed=1)

Контекст

Репо: /opt/zakaz_dashboard/dashboard-mvp
Интеграция: dashboard-mvp/integrations/qtickets_api
Исследование: /workspaces/Zakaz_Dashboard/Исследование.md
Текущие симптомы: stg_qtickets_api_orders_raw и fact_qtickets_sales_daily пустые, meta_job_runs пишет "orders": 0
Исследование подтверждает: QTickets отдает заказы только при явном payed=1
Цель
Добавить обязательный фильтр payed=1 (и при необходимости другие параметры по статусам) ко всем вызовам /orders, чтобы получать реальные продажи, и убедиться, что данные пишутся в ClickHouse.

1. Подготовка
Ознакомься с Исследование.docx — там указаны гипотезы и подтверждение, что параметр payed=1 обязателен.
Проверь dev-лог qtickets_loader.log или свежий вывод docker run — убеждаемся, что текущий код не отправляет payed.
2. Правки кода
Файл: dashboard-mvp/integrations/qtickets_api/client.py (или другой, где формируется запрос GET /orders).
Изменение:
В параметрах fetch_orders_get добавить payed=1. Следи, чтобы параметр не потерялся при пагинации (в каждой итерации).
Если в коде предусмотрены дополнительные фильтры (status, deleted_at), проверить, нужны ли по итогам исследования ещё параметры (например, since, payment_status — см. документ).
Добавить debug-лог: какой URL/параметры реально уйдут (чтобы легче было проверять).
Импорты: ничего лишнего не добавляем; фиксим стилевые моменты, если нужно.
3. Юнит/интеграционные тесты (если есть)
Обновить/добавить тест для fetch_orders_get (проверка, что payed присутствует).
Если тестов нет, хотя бы вывести в лог при запуске --verbose.
4. Проверка в dev-среде
QTICKETS_SINCE_HOURS=720 (или больше) в /opt/zakaz_dashboard/secrets/.env.qtickets_api.
Запуск:
docker run --rm \
  --network clickhouse_default \
  --env-file /opt/zakaz_dashboard/secrets/.env.qtickets_api \
  qtickets_api:latest
Подтверждаем, что появились строки:
docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "SELECT count(), min(order_ts), max(order_ts) FROM zakaz.stg_qtickets_api_orders_raw;"

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT
      min(sales_date),
      max(sales_date),
      sum(tickets_sold),
      sum(revenue)
    FROM zakaz.fact_qtickets_sales_daily;
  "
Проверяем meta_job_runs:
docker exec ch-зakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT job, status, started_at, finished_at, message
    FROM zakaz.meta_job_runs
    WHERE job = 'qtickets_api'
    ORDER BY finished_at DESC
    LIMIT 5
    FORMAT PrettyCompact;
  "
— ожидаем "orders": N с N > 0.
5. Граница (если данных всё равно нет)
Ручной curl:
curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=<дата>" | jq '.'
Если ответа нет — эскалация: проверить токен/scopes (в документе указано, что надо уточнить у QTickets). Но сначала кодер должен убедиться, что payed действительно уходит.
6. Что приложить после выполнения
Скрин/файл с показателями ClickHouse (counts, даты).
Лог запуска (qtickets_loader.log или stdout), где видно запрос /orders с payed=1.
Обновлённый meta_job_runs (включая orders: N).
Сделать заметку в README или ADR, что фильтр обязателен (с ссылкой на исследование).
Если пришлось обращаться к QTickets, описать ответ и обновления scopes.
Критерии приёмки

fetch_orders_get всегда добавляет payed=1.
stg_qtickets_api_orders_raw и fact_qtickets_sales_daily после запуска имеют ненулевые строки (стараемся вытянуть историю).
Код стиля/линтер (make lint или python -m compileall) — без ошибок.
Подготовлен отчёт (ссылки на ClickHouse и логи).
Результаты исследования учтены, документ упомянут как источник.
После выполнения — сообщить, на каких периодах (since) нашли заказы, и убедиться, что боевой режим (QTICKETS_SINCE_HOURS привычный, например 4) продолжит забирать новые продажи.