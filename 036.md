Задача для кодера: “QTickets /orders — пошаговая проверка всех гипотез”
Цель: найти, почему QTickets API не отдает продажи, при том что реальные продажи есть. Выполнять строго по шагам. Каждая попытка документируется, никаких «сам придумал».

Общие правила
Рабочая директория: /opt/zakaz_dashboard/dashboard-mvp.
Конфигурация: /opt/zakaz_dashboard/secrets/.env.qtickets_api (используем боевые значения).
Логи и артефакты складываем в /opt/zakaz_dashboard/logs/qtickets_orders_debug/. Перед началом:
mkdir -p /opt/zakaz_dashboard/logs/qtickets_orders_debug
rm -f /opt/zakaz_dashboard/logs/qtickets_orders_debug/*
Каждый блок завершается сохранением вывода в файл вида stepXX_description.txt (чтобы потом легко приложить).
Везде используем токен из .env (переменная QTICKETS_TOKEN) и ORG_NAME.
Время/дата формируем в MSK: date -u -d '...' +%Y-%m-%dT%H:%M:%S%z.
Источник правды: D:\Projects\Zakaz_Dashboard\Исследование.docx (перенесён в репозиторий в Исследование.md).

Шаг 0. Подготовить переменные окружения (раз и навсегда для сессии)
source /opt/zakaz_dashboard/secrets/.env.qtickets_api
export QTICKETS_BASE_URL
export QTICKETS_TOKEN
export ORG_NAME
export REPORT_TZ   # должно быть Europe/Moscow
Проверить, что переменные заполнены, и записать их в step00_env.txt (без токена — маскируем, например, token_fp).

A. Проверяем GET /orders с payed=1
A1. Базовый запрос за 30 дней
SINCE=$(date -u -d '30 days ago' +%Y-%m-%dT%H:%M:%S%z)
curl -s -D - \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=$SINCE&page=1" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepA1_get_orders.json
Заголовок ответа сохранить в stepA1_get_orders.headers.txt.
В stepA1_get_orders.outcome.txt записать: HTTP-код, количество элементов (используй jq '.|length' если массив).
A2. Тот же запрос, но +per_page=200
curl -s -D - \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=$SINCE&page=1&per_page=200" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepA2_get_orders_perpage.json
Аналогично сохранить заголовки и длину.
A3. Проверка второй страницы (если первая вернула >0)
curl -s -D - \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=$SINCE&page=2&per_page=200" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepA3_get_orders_page2.json
B. Разные статусы в GET
Если шаг A вернул пусто:

B1. Статус status=paid
curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&status=paid&since=$SINCE&page=1&per_page=200" \
  | tee /opt/zakаз_dashboard/logs/qtickets_orders_debug/stepB1_get_orders_status_paid.json
B2. Убираем payed, пробуем только status=paid
curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&status=paid&since=$SINCE&page=1&per_page=200" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepB2_get_orders_status_only.json
B3. Статус status=completed
Аналогично B1 (меняем на status=completed), сохраняем в stepB3.

C. Временные рамки (обрезаем периоды)
C1. За последние 24 часа
SINCE24=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%S%z)
curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=$SINCE24&page=1&per_page=200" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepC1_get_orders_24h.json
C2. За 3 месяца
SINCE90=$(date -u -d '90 days ago' +%Y-%m-%dT%H:%M:%S%z)
curl -s \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders?organization=$ORG_NAME&payed=1&since=$SINCE90&page=1&per_page=200" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepC2_get_orders_90d.json
D. Прямой запрос на конкретный order_id
Если из email известен номер заказа ORDER_ID, проверяем:

curl -s -D - \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders/$ORDER_ID?organization=$ORG_NAME" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepD_get_orders_id_$ORDER_ID.json
Здесь обязательно нужен реальный ID. Если заказ найден — значит токен видит продажи.
E. Проверяем POST /orders/filter (формат из исследования)
E1. Пробуем JSON тело (из исследования)
Создай файл /opt/zakaz_dashboard/logs/qtickets_orders_debug/post_filter_body.json:

{
  "filters": [
    {"column": "payed", "operator": "=", "value": 1},
    {"column": "payed_at", "operator": ">=", "value": "2025-10-01T00:00:00+03:00"},
    {"column": "payed_at", "operator": "<", "value": "2025-11-03T23:59:59+03:00"}
  ],
  "page": 1,
  "per_page": 200
}
Запрос:

curl -s -D - \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  -H "Content-Type: application/json" \
  -X POST \
  --data @/opt/zakaz_dashboard/logs/qtickets_orders_debug/post_filter_body.json \
  "$QTICKETS_BASE_URL/orders/filter" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepE1_post_filter.json
Если endpoint /orders/filter не существует — получим 404/405. Зафиксировать.
E2. POST на /orders с filters (как у кодера)
Создай post_orders_body.json:

{
  "filters": [
    {"column": "payed", "operator": "=", "value": 1},
    {"column": "payed_at", "operator": ">=", "value": "2025-10-01T00:00:00+03:00"},
    {"column": "payed_at", "operator": "<", "value": "2025-11-03T23:59:59+03:00"}
  ],
  "page": 1,
  "per_page": 200
}
Запрос:

curl -s -D - \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  -H "Content-Type: application/json" \
  -X POST \
  --data @/opt/zakaz_dashboard/logs/qtickets_orders_debug/post_orders_body.json \
  "$QTICKETS_BASE_URL/orders" \
  | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepE2_post_orders.json
Лог HTTP кода и body_preview в stepE2_post_orders.headers.txt.
F. Проверка status=503 (повтор запроса) и задержки
Если где-то появляется 503 (как в логе задач 035), повторяем тот же curl через 5 минут (шаг F1). Если 503 стабилен — фиксируем request_id (если в header есть), в stepF1_503.txt.

G. Интеграция — запуск loader после успешного GET
Если на каком-то GET или POST мы получили массив >0:

Обнови код (fetch_orders_get) так, чтобы использовался соответствующий формат (например, GET c payed=1 или POST /orders/filter).

В .env поставь нужное окно QTICKETS_SINCE_HOURS (чтобы покрыть период, в котором мы нашли данные).

Запусти загрузчик:

docker run --rm \
  --network clickhouse_default \
  --env-file /opt/zakaz_dashboard/secrets/.env.qtickets_api \
  qtickets_api:latest \
  --verbose 2>&1 | tee /opt/zakaz_dashboard/logs/qtickets_orders_debug/stepG_loader.log
Проверка ClickHouse:

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "SELECT count(), min(order_ts), max(order_ts) FROM zakaz.stg_qtickets_api_orders_raw;"
Сохранить в stepG_loader_stg.txt.

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT
      min(sales_date),
      max(sales_date),
      sum(tickets_sold),
      sum(revenue)
    FROM zakaz.fact_qtickets_sales_daily;
  "
Сохранить в stepG_loader_fact.txt.

H. Итоговый отчёт
Собрать в final_report.md (в каталоге логов):

Summary каждого шага: какой HTTP-код, длина ответа, какие параметры помогли.
Таблица шаг → HTTP-code → длина → примечание.
Если ни один запрос не дал заказы — выписать, что проверяли (GET /orders с payed/status/since, POST /orders/filter, POST /orders), и указать, что все возвращают 503 или пусто.
Приложить qtickets_orders_debug (архив tar.gz):
cd /opt/zakaz_dashboard/logs
tar -czf qtickets_orders_debug.tar.gz qtickets_orders_debug
Если остаётся 503 / пусто
Закрепить в итоговом отчёте:
точный URL, тело запроса;
время запроса (по UTC и MSK);
request_id (если в заголовке приходит);
результат curl -I (HEAD);
ответ {"error":"Unknown error","status":503,...} — приложить.
После этого подготовить письмо/тикет в QTickets Support: “token X, org Y. GET /orders?… → 503. Пожалуйста, подскажите, какие параметры нужны / протестируйте endpoint.”
Важно
До завершения задачи никаких изменений в секретах (не менять токен).
Каждое отклонение от инструкций фиксировать в README_TESTING.md в том же каталоге логов.
Никаких «от себя» запросов без логов — иначе проверка не будет считаться завершенной.