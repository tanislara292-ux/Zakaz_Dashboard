Задача: “Боевой прогон QTickets + ClickHouse на dev-сервере”
Цель: подтвердить, что свежий код (POST с where) вытягивает актуальные продажи и корректно загружает их в ClickHouse.

База
Рабочая среда: dev-сервер /opt/zakaz_dashboard/dashboard-mvp
Секреты: /opt/zakaz_dashboard/secrets/.env.qtickets_api (боевые значения, не менять токен)
ClickHouse контейнер: ch-zakaz
Логи/артефакты: /opt/zakaz_dashboard/logs/qtickets_smoke_2025/
mkdir -p /opt/zakaz_dashboard/logs/qtickets_smoke_2025
rm -f /opt/zakaz_dashboard/logs/qtickets_smoke_2025/*
Шаг 1. Подготовка env
Загрузить переменные и зафиксировать (маскируя токен):
source /opt/zakaz_dashboard/secrets/.env.qtickets_api
{
  echo "QTICKETS_BASE_URL=$QTICKETS_BASE_URL"
  echo "ORG_NAME=$ORG_NAME"
  echo "REPORT_TZ=$REPORT_TZ"
  echo "TOKEN_FP=$(echo "$QTICKETS_TOKEN" | sed 's/^\(....\).*/\1***/')"
  echo "QTICKETS_SINCE_HOURS=$QTICKETS_SINCE_HOURS"
} > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step01_env.txt
Шаг 2. Локализуем окно свежих продаж
Возьмите дату SINCE_CURR=$(TZ='Europe/Moscow' date -d '30 days ago' +%Y-%m-%dT%H:%M:%S%z) — за 30 дней.

curl на /orders с новым форматом (POST body):

SINCE_CURR=... # как выше
NOW_CURR=$(TZ='Europe/Moscow' date +"%Y-%m-%dT%H:%M:%S%z")

cat <<'EOF' > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/post_body.json
{
  "where": [
    { "column": "payed", "value": 1 },
    { "column": "payed_at", "operator": ">=", "value": "SINCE_PLACEHOLDER" },
    { "column": "payed_at", "operator": "<", "value": "UNTIL_PLACEHOLDER" }
  ],
  "orderBy": { "payed_at": "desc" },
  "per_page": 200
}
EOF
Замените SINCE_PLACEHOLDER/UNTIL_PLACEHOLDER на значения переменных (через sed или python):

python - <<'PY'
import json, os
SINCE = os.environ["SINCE_CURR"]
UNTIL = os.environ["NOW_CURR"]
body = json.load(open("/opt/zakaz_dashboard/logs/qtickets_smoke_2025/post_body.json"))
body["where"][1]["value"] = SINCE
body["where"][2]["value"] = UNTIL
json.dump(body, open("/opt/zakaz_dashboard/logs/qtickets_smoke_2025/post_body.json", "w"), ensure_ascii=False)
PY
Запрос:

curl -s -D /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step02_headers.txt \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  -H "Content-Type: application/json" \
  -X POST \
  --data @/opt/zakaz_dashboard/logs/qtickets_smoke_2025/post_body.json \
  "$QTICKETS_BASE_URL/orders" \
  > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step02_body.json
В step02_outcome.txt укажите:

HTTP-код,
количество элементов (jq '.data | length'),
первые 2 заказа (jq '.data[:2]'),
диапозон payed_at.
Если ответ пустой → фиксируем [] и продолжаем (айпи/токен проверим позже через конкретный order_id).

Шаг 3. Тестовый fetch_orders_get
Запускаем Python-скрипт:
python - <<'PY'
from integrations.qtickets_api.client import QticketsApiClient
from integrations.common.time import now_msk
from pathlib import Path
import os, json

client = QticketsApiClient(
    base_url=os.environ["QTICKETS_BASE_URL"],
    token=os.environ["QTICKETS_TOKEN"],
    org_name=os.environ.get("ORG_NAME"),
)

end = now_msk()
start = end - timedelta(hours=720)  # 30 дней
orders = client.fetch_orders_get(start, end)

Path("/opt/zakaz_dashboard/logs/qtickets_smoke_2025/step03_orders.json").write_text(
    json.dumps(orders, ensure_ascii=False, indent=2)
)
Path("/opt/zakaz_dashboard/logs/qtickets_smoke_2025/step03_stats.txt").write_text(
    f"count={len(orders)}\nfirst_payed_at={orders[0]['payed_at'] if orders else 'N/A'}\n"
)
PY
подтвердить:

count > 0?
Если 0 → приложить JSON ([]) и отметить, что API всё ещё не отдаёт свежие заказы.
Шаг 4. Подготовка ClickHouse
Очистить staging (если нужно):

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "TRUNCATE TABLE zakaz.stg_qtickets_api_orders_raw"
Очистить факт (по желанию):

docker exec ch-зakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "TRUNCATE TABLE zakaz.fact_qtickets_sales_daily"
Убедиться, что таблицы пустые:

docker exec ch-зakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "SELECT count() FROM zakaz.stg_qtickets_api_orders_raw"
(Записать в step04_counts_before.txt)

Шаг 5. Боевое выполнение loader
В .env выставить широкое окно (например, QTICKETS_SINCE_HOURS=720 — 30 дней).

Запуск:

docker run --rm \
  --network clickhouse_default \
  --env-file /opt/zakaz_dashboard/secrets/.env.qtickets_api \
  qtickets_api:latest \
  --verbose 2>&1 | tee /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step05_loader.log
Проверка ClickHouse:

docker exec ch-zakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "SELECT count(), min(order_ts), max(order_ts) FROM zakaz.stg_qtickets_api_orders_raw"
  > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step05_stg_after.txt
docker exec ch-зakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT
      count(),
      min(sales_date),
      max(sales_date),
      sum(tickets_sold),
      sum(revenue)
    FROM zakaz.fact_qtickets_sales_daily
  " > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step05_fact_after.txt
Шаг 6. Проверка meta_job_runs
Последние записи:
docker exec ch-зakaz clickhouse-client \
  --user=admin --password=admin_pass \
  -q "
    SELECT job, status, started_at, finished_at, message
    FROM zakaz.meta_job_runs
    WHERE job = 'qtickets_api'
    ORDER BY finished_at DESC
    LIMIT 5 FORMAT PrettyCompact
  " > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step06_meta.txt
Обратить внимание на orders: должно быть >0.
Шаг 7. Перекрёстная проверка с письмом
Выбери один реальный order_id из свежей почты. curl вручную:
ORDER_ID=... # из письма
curl -s -D /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step07_headers.txt \
  -H "Authorization: Bearer $QTICKETS_TOKEN" \
  "$QTICKETS_BASE_URL/orders/$ORDER_ID?organization=$ORG_NAME" \
  > /opt/zakaz_dashboard/logs/qtickets_smoke_2025/step07_body.json
Проверить, что JSON содержит нужные поля и payed=true.
Шаг 8. Итоговый отчёт
Скомпоновать в final_report.md:
Таблица по шагам (URL, HTTP-код, count, даты).
Содержимое ClickHouse после загрузки.
Если заказы по 2025 отсутствуют → фиксируем count=0, orders=[], message={"orders":0...}. Этот отчёт нужен для коммуникации с QTickets.
Архив:
cd /opt/zakaz_dashboard/logs
tar -czf qtickets_smoke_2025.tar.gz qtickets_smoke_2025
Шаг 9. Уборка
Если меняли QTICKETS_SINCE_HOURS, вернуть прежнее (например, 4).
Убедиться, что ClickHouse не оставили пустым (если staging/fact были очищены для теста — при необходимости восстановить).
Условия завершения

Все файлы (curl-ответы, хэдеры, логи, выводы CH) присутствуют.
В final_report.md чётко описано, получены ли свежие продажи. Если да — указаны count, min/max payed_at, revenue.
Если нет — всё равно считаем задачу выполненной, но отчёт с доказательствами готов (оно нужно будет для QTickets support).
Loader вывод без ошибок, meta_job_runs.message фиксирует количество заказов.
После этого можно результировать и передать отчёт заказчику.